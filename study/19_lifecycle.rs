/*
    --TODO: Rust生命周期
        Rust生命周期机制是与所有权机制同等重要的资源重要机制。
        之所以引入这个概念主要是应对复杂类型系统中资源管理的问题。
        引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算。
        但引用往往导致极其复杂的资源管理问题，首先认识一下垂悬引用:

    {
        let r;
        {
            let x = 5;
            r = &x;
        }
        println!("r: {}", r);
    }

*/


/*
    --TODO:
        一直以来，我们都在结构体中使用String而不用&str

    longer函数取s1和s2两个字符串切片中切片中较长的一个返回其引用值。但只
  这段代码不会通过编译，原因是返回值引用可能会返回过期的引用
*/
/* 
    fn longer(s1: &str, s2: &str) -> &str 
    {
        if s2.len() > s1.len()
        {
            s2
        }
        else 
        {
            s1
        }
    }

    /*
        我们需要用泛型声明来规范生命周期的名称，随后函数返回值的生命周期将与两个参数的
    生命周期一致。
    */

    fn main()
    {
        let r;
        {
            let s1 = "rust";
            let s2 = "ecmascript";
            r = longer(s1, s2);
        }
        println!("{} is longer", r);
    }
    /*
        上面代码虽然经过了比较，但r被使用的时候源值s1和s2都已经失效了。当然我们可以把r的使用移到s1和s2的生命
    周期范围以内防止这种错误的产生，但对于函数来说，它并不能直到自己以外的地方是什么情况，为了保障自己传递出
    去的值是正常的，必选所有权原则消除一切危险，所以longer函数并不能编译。
    */
*/


/*
    --TODO: 生命周期注释
        生命周期注释是描述引用生命周期的办法。
        虽然这样并不能够改变引用的生命周期，但可以在合适的地方声明两个引用的生命周期一致。
        生命周期注释用单引号开头，跟着一个小写字母单词:

    &i32        常规引用
    &'a i32     含有生命周期注释的引用
    &'a mut i32 可变型含有生命周期注释的引用
*/

fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str 
{
    if s2.len() > s1.len()
    {
        s2
    }
    else
    {
        s1
    }
}

/*
    我们需要用泛型声明来规范声明周期的名称，随后函数返回值的生命周期将与两个参数的生命周期一
  致，所以在调用时可以这样写:
*/
fn main()
{
    let r;
    {
        let s1 = "rust";
        let s2 = "ecmascript";
        r = longer(s1, s2);
        println!("{} is longer", r);
    }

    /*
    注意: 别忘记了自动类型判断的原则

        --TODO: 结构体使用字符串切片引用:
     */
    struct Str<'a>
    {
        content: &'a str
    }
    let s = Str {
        content: "string_slice"
    };
    println!("s.content = {}", s.content);
}